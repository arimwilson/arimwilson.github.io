<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Cyberpunk Maze Runner</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        font-family: "Press Start 2P", cursive;
        background-color: #0a0a0a;
        color: #00ff00;
        margin: 0;
        padding: 0;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        touch-action: none;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;
        overflow: hidden;
      }
      canvas {
        display: block;
        background-color: #111;
      }
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        opacity: 1;
        transition: opacity 1s ease-out;
        padding: 20px;
        box-sizing: border-box;
      }
      .overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }
      .overlay h1 {
        font-size: 2.5rem;
        margin-bottom: 20px;
        color: #ff00ff;
        text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
      }
      .overlay p {
        font-size: 1rem;
        margin-bottom: 10px;
        line-height: 1.5;
      }
      .overlay button {
        font-family: "Press Start 2P", cursive;
        background-color: #00ffff;
        color: #000;
        border: none;
        padding: 15px 30px;
        font-size: 1.2rem;
        cursor: pointer;
        border-radius: 5px;
        box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
        transition: background-color 0.3s, box-shadow 0.3s;
      }
      .overlay button:hover {
        background-color: #00dddd;
        box-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff;
      }

      #timerDisplay,
      #scoreDisplay {
        position: absolute;
        top: 10px;
        font-size: 1.5rem;
        color: #00ff00;
        text-shadow: 0 0 5px #00ff00;
        z-index: 5;
      }
      #timerDisplay {
        left: 10px;
      }
      #scoreDisplay {
        right: 10px;
      }

      #mazeInfoDisplay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(10, 10, 10, 0.85);
        padding: 30px;
        border-radius: 10px;
        border: 2px solid #00ffff;
        text-align: center;
        z-index: 15;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        pointer-events: none;
      }
      #mazeInfoDisplay.visible {
        opacity: 1;
      }
      #mazeInfoDisplay h2 {
        font-size: 2rem;
        color: #ff00ff;
        margin-bottom: 10px;
      }
      #mazeInfoDisplay p {
        font-size: 1.2rem;
        color: #00ffff;
      }

      #highScoreScreen {
        background-color: rgba(0, 0, 0, 0.95);
      }
      #highScoreScreen h1 {
        color: #00ffff;
        text-shadow: 0 0 10px #00ffff;
      }
      #highScoreList {
        list-style: none;
        padding: 0;
        margin-top: 20px;
        max-height: 45vh; /* Adjusted for potential new message */
        overflow-y: auto; /* Allow scrolling if list is long */
        width: 80%;
        max-width: 400px;
      }
      #highScoreList li {
        font-size: 1rem;
        padding: 8px 0;
        border-bottom: 1px dashed #333;
        color: #00ff00;
        opacity: 0;
        transform: translateY(20px);
      }
      #highScoreList li:last-child {
        border-bottom: none;
      }
      #highScoreList li.visible {
        opacity: 1;
        transform: translateY(0);
        transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      }
      #dailyLockoutMessage {
        font-size: 1rem;
        color: #ff8800; /* Orange for notice */
        margin-top: 15px;
        display: none; /* Hidden by default */
      }
      #finalScoreMessage {
        margin-top: 15px;
      }
      #rankMessage {
        margin-top: 20px;
        font-size: 1.5rem;
        color: #ffdd00;
        text-shadow: 0 0 8px #ffdd00;
        opacity: 0;
        animation: flash 1.5s infinite;
      }

      @keyframes flash {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }

      @media (max-width: 600px) {
        .overlay h1 {
          font-size: 1.8rem;
        }
        .overlay p {
          font-size: 0.9rem;
        }
        .overlay button {
          font-size: 1rem;
          padding: 12px 24px;
        }
        #timerDisplay,
        #scoreDisplay {
          font-size: 1.2rem;
        }
        #mazeInfoDisplay h2 {
          font-size: 1.5rem;
        }
        #mazeInfoDisplay p {
          font-size: 1rem;
        }
        #highScoreList li {
          font-size: 0.9rem;
        }
        #rankMessage {
          font-size: 1.2rem;
        }
        #dailyLockoutMessage {
          font-size: 0.9rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="mazeCanvas"></canvas>

      <div id="timerDisplay">Time: 03:00</div>
      <div id="scoreDisplay">Score: 0</div>

      <div id="introScreen" class="overlay">
        <h1>Cyberpunk Maze Runner</h1>
        <p>Navigate the neon grid. Reach the exit. Beat the clock.</p>
        <p>Touch screen edges or use WASD to move. One run per day.</p>
        <button id="startButton">Start Run</button>
      </div>

      <div id="mazeInfoDisplay">
        <h2 id="mazeInfoNumber"></h2>
        <p id="mazeInfoName"></p>
      </div>

      <div id="highScoreScreen" class="overlay hidden">
        <h1 id="highScoreTitle">Run Terminated</h1>
        <p id="dailyLockoutMessage">
          You've already run the Grid today, Netrunner! Check back tomorrow.
        </p>
        <p id="finalScoreMessage">Mazes Cleared: 0</p>
        <h2>High Scores:</h2>
        <ul id="highScoreList"></ul>
        <p id="rankMessage" style="opacity: 0">Calculating rank...</p>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("mazeCanvas");
      const ctx = canvas.getContext("2d");
      const gameContainer = document.getElementById("gameContainer");

      const introScreen = document.getElementById("introScreen");
      const startButton = document.getElementById("startButton");
      const highScoreScreen = document.getElementById("highScoreScreen");
      const highScoreTitle = document.getElementById("highScoreTitle");
      const highScoreList = document.getElementById("highScoreList");
      const dailyLockoutMessage = document.getElementById(
        "dailyLockoutMessage"
      );
      const finalScoreMessage = document.getElementById("finalScoreMessage");
      const rankMessage = document.getElementById("rankMessage");
      // playAgainButton is removed
      const mazeInfoDisplay = document.getElementById("mazeInfoDisplay");
      const mazeInfoNumber = document.getElementById("mazeInfoNumber");
      const mazeInfoName = document.getElementById("mazeInfoName");
      const timerDisplay = document.getElementById("timerDisplay");
      const scoreDisplay = document.getElementById("scoreDisplay");

      let cellSize,
        rows,
        cols,
        maze,
        player,
        exit,
        score,
        timeLeft,
        gameTimerInterval,
        gameState;
      const GAME_DURATION = 3 * 60; // 3 minutes

      const neonColorPalettes = [
        {
          wall: "#ff00ff",
          background: "#1a001a",
          player: "#00ffff",
          exit: "#ffff00",
        },
        {
          wall: "#00ffff",
          background: "#001a1a",
          player: "#ff00ff",
          exit: "#ff8800",
        },
        {
          wall: "#00ff00",
          background: "#001a00",
          player: "#ffff00",
          exit: "#ff00ff",
        },
        {
          wall: "#ffff00",
          background: "#1a1a00",
          player: "#00ff00",
          exit: "#00ffff",
        },
        {
          wall: "#ff8800",
          background: "#1a0f00",
          player: "#00ffff",
          exit: "#ff00ff",
        },
      ];
      let currentPalette;

      const namePrefixes = [
        "Neo-",
        "Cryo-",
        "Zero-",
        "Data-",
        "Glitch-",
        "Chrome-",
        "Synth-",
        "Void-",
        "Hex-",
        "Pulse-",
      ];
      const nameCores = [
        "Sector",
        "Grid",
        "Matrix",
        "Spire",
        "Node",
        "Core",
        "Zone",
        "District",
        "Haven",
        "Circuit",
      ];
      const nameSuffixes = [
        "Prime",
        "Omega",
        "Ultra",
        "X",
        "9000",
        "Zero",
        "Syndicate",
        "Collective",
        "System",
        "Net",
      ];

      function getRandomElement(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }
      function generateCyberpunkName() {
        return `${getRandomElement(namePrefixes)}${getRandomElement(
          nameCores
        )} ${getRandomElement(nameSuffixes)}`;
      }

      function resizeCanvas() {
        canvas.width = gameContainer.clientWidth;
        canvas.height = gameContainer.clientHeight;
        const minDimension = Math.min(canvas.width, canvas.height);
        cellSize = Math.floor(minDimension / 15);
        if (cellSize < 15) cellSize = 15;
        cols = Math.floor(canvas.width / cellSize);
        rows = Math.floor(canvas.height / cellSize);
        if (cols < 1) cols = 1;
        if (rows < 1) rows = 1;
        const effectiveWidth = cols * cellSize;
        const effectiveHeight = rows * cellSize;
        canvas.style.marginLeft = `${(canvas.width - effectiveWidth) / 2}px`;
        canvas.style.marginTop = `${(canvas.height - effectiveHeight) / 2}px`;
        canvas.width = effectiveWidth;
        canvas.height = effectiveHeight;
        if (gameState === "playing") {
          setupNewMaze();
        }
      }

      function createGrid() {
        /* ... (same as before) ... */
        const grid = [];
        for (let r = 0; r < rows; r++) {
          grid[r] = [];
          for (let c = 0; c < cols; c++) {
            grid[r][c] = {
              r,
              c,
              walls: { top: true, right: true, bottom: true, left: true },
              visited: false,
            };
          }
        }
        return grid;
      }
      function generateMaze() {
        /* ... (same as before, ensure startR/startC are valid) ... */
        maze = createGrid();
        if (rows === 0 || cols === 0) return;
        const stack = [];
        const startR = 0; // Player always starts at 0,0
        const startC = 0;
        let current = maze[startR][startC];
        current.visited = true;
        do {
          const neighbors = getUnvisitedNeighbors(current);
          if (neighbors.length > 0) {
            stack.push(current);
            const randomNeighbor =
              neighbors[Math.floor(Math.random() * neighbors.length)];
            removeWall(current, randomNeighbor);
            current = randomNeighbor;
            current.visited = true;
          } else if (stack.length > 0) {
            current = stack.pop();
          }
        } while (stack.length > 0);
      }
      function getUnvisitedNeighbors(cell) {
        /* ... (same as before) ... */
        const { r, c } = cell;
        const neighbors = [];
        if (r > 0 && !maze[r - 1][c].visited) neighbors.push(maze[r - 1][c]);
        if (c < cols - 1 && !maze[r][c + 1].visited)
          neighbors.push(maze[r][c + 1]);
        if (r < rows - 1 && !maze[r + 1][c].visited)
          neighbors.push(maze[r + 1][c]);
        if (c > 0 && !maze[r][c - 1].visited) neighbors.push(maze[r][c - 1]);
        return neighbors;
      }
      function removeWall(a, b) {
        /* ... (same as before) ... */
        const dr = a.r - b.r;
        if (dr === 1) {
          a.walls.top = false;
          b.walls.bottom = false;
        } else if (dr === -1) {
          a.walls.bottom = false;
          b.walls.top = false;
        }
        const dc = a.c - b.c;
        if (dc === 1) {
          a.walls.left = false;
          b.walls.right = false;
        } else if (dc === -1) {
          a.walls.right = false;
          b.walls.left = false;
        }
      }
      function drawMaze() {
        /* ... (same as before) ... */
        if (!currentPalette) return;
        ctx.fillStyle = currentPalette.background;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = currentPalette.wall;
        ctx.lineWidth = Math.max(1, Math.floor(cellSize / 12));
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const cell = maze[r][c];
            const x = c * cellSize;
            const y = r * cellSize;
            if (cell.walls.top) {
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x + cellSize, y);
              ctx.stroke();
            }
            if (cell.walls.right) {
              ctx.beginPath();
              ctx.moveTo(x + cellSize, y);
              ctx.lineTo(x + cellSize, y + cellSize);
              ctx.stroke();
            }
            if (cell.walls.bottom) {
              ctx.beginPath();
              ctx.moveTo(x + cellSize, y + cellSize);
              ctx.lineTo(x, y + cellSize);
              ctx.stroke();
            }
            if (cell.walls.left) {
              ctx.beginPath();
              ctx.moveTo(x, y + cellSize);
              ctx.lineTo(x, y);
              ctx.stroke();
            }
          }
        }
      }
      function drawPlayer() {
        /* ... (same as before) ... */
        if (!currentPalette || !player) return;
        ctx.fillStyle = currentPalette.player;
        const padding = cellSize * 0.15;
        ctx.fillRect(
          player.c * cellSize + padding,
          player.r * cellSize + padding,
          cellSize - 2 * padding,
          cellSize - 2 * padding
        );
      }
      function drawExit() {
        /* ... (same as before) ... */
        if (!currentPalette || !exit) return;
        ctx.fillStyle = currentPalette.exit;
        const padding = cellSize * 0.1;
        const centerX = exit.c * cellSize + cellSize / 2;
        const centerY = exit.r * cellSize + cellSize / 2;
        const radius = cellSize / 2 - padding;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = currentPalette.background;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }

      function setupNewMaze() {
        currentPalette =
          getRandomElement(
            neonColorPalettes.filter((p) => p !== currentPalette)
          ) || neonColorPalettes[0];
        generateMaze();
        player = { r: 0, c: 0 };
        exit = { r: Math.max(0, rows - 1), c: Math.max(0, cols - 1) };
        if (rows <= 1 && cols <= 1) {
          /* Instant win for 1x1 */
        } else if (player.r === exit.r && player.c === exit.c) {
          if (cols > 1) exit.c = cols - 1;
          else if (rows > 1) exit.r = rows - 1;
        }
        drawAll();
      }
      function drawAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMaze();
        drawPlayer();
        drawExit();
      }

      function movePlayer(dr, dc) {
        /* ... (same as before) ... */
        if (gameState !== "playing" || !maze) return;
        const newR = player.r + dr;
        const newC = player.c + dc;
        if (newR < 0 || newR >= rows || newC < 0 || newC >= cols) return;
        if (!maze[player.r] || !maze[player.r][player.c]) return;
        const currentCell = maze[player.r][player.c];
        if (dr === -1 && currentCell.walls.top) return;
        if (dr === 1 && currentCell.walls.bottom) return;
        if (dc === -1 && currentCell.walls.left) return;
        if (dc === 1 && currentCell.walls.right) return;
        player.r = newR;
        player.c = newC;
        drawAll();
        if (player.r === exit.r && player.c === exit.c) {
          score++;
          updateScoreDisplay();
          if (timeLeft > 0) {
            startPreMazeTransition();
          } else {
            endGame();
          }
        }
      }
      function handleTouch(event) {
        /* ... (same as before) ... */
        event.preventDefault();
        if (gameState !== "playing" || !event.touches.length) return;
        const touch = event.touches[0];
        const rect = canvas.getBoundingClientRect();
        const touchX =
          touch.clientX - rect.left - parseFloat(canvas.style.marginLeft || 0);
        const touchY =
          touch.clientY - rect.top - parseFloat(canvas.style.marginTop || 0);
        const thirdWidth = canvas.width / 3;
        const thirdHeight = canvas.height / 3;
        if (touchX > thirdWidth && touchX < 2 * thirdWidth) {
          if (touchY < thirdHeight) movePlayer(-1, 0);
          else if (touchY > 2 * thirdHeight) movePlayer(1, 0);
        } else if (touchY > thirdHeight && touchY < 2 * thirdHeight) {
          if (touchX < thirdWidth) movePlayer(0, -1);
          else if (touchX > 2 * thirdWidth) movePlayer(0, 1);
        }
      }
      function handleKeyDown(event) {
        /* ... (same as before) ... */
        if (gameState !== "playing") return;
        switch (event.key.toLowerCase()) {
          case "w":
          case "arrowup":
            movePlayer(-1, 0);
            break;
          case "s":
          case "arrowdown":
            movePlayer(1, 0);
            break;
          case "a":
          case "arrowleft":
            movePlayer(0, -1);
            break;
          case "d":
          case "arrowright":
            movePlayer(0, 1);
            break;
        }
      }

      function startGame() {
        // This function is called only if the player hasn't played today
        score = 0;
        timeLeft = GAME_DURATION;
        updateScoreDisplay();
        updateTimerDisplay();
        resizeCanvas();
        startPreMazeTransition();
        if (gameTimerInterval) clearInterval(gameTimerInterval);
        gameTimerInterval = setInterval(updateGameTimer, 1000);
        canvas.addEventListener("touchstart", handleTouch, { passive: false });
        window.addEventListener("keydown", handleKeyDown);
      }

      function startPreMazeTransition() {
        gameState = "preMaze";
        mazeInfoNumber.textContent = `Maze ${score + 1}`;
        mazeInfoName.textContent = generateCyberpunkName();
        mazeInfoDisplay.classList.add("visible");
        setTimeout(() => {
          mazeInfoDisplay.classList.remove("visible");
          setTimeout(() => {
            gameState = "playing";
            setupNewMaze();
          }, 500);
        }, 1500);
      }

      function updateGameTimer() {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) {
          endGame();
        }
      }
      function updateTimerDisplay() {
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        timerDisplay.textContent = `Time: ${String(minutes).padStart(
          2,
          "0"
        )}:${String(seconds).padStart(2, "0")}`;
      }
      function updateScoreDisplay() {
        scoreDisplay.textContent = `Score: ${score}`;
      }

      function endGame() {
        gameState = "gameOver";
        clearInterval(gameTimerInterval);
        canvas.removeEventListener("touchstart", handleTouch);
        window.removeEventListener("keydown", handleKeyDown);

        // Mark that the player has used their run for the day
        const currentDateISO = new Date().toISOString().split("T")[0];
        localStorage.setItem("cyberpunkMazeRunnerLastPlayDate", currentDateISO);

        displayHighScores(true); // True because a game just finished
      }

      function showAlreadyPlayedScreen() {
        gameState = "gameOver"; // Treat as a form of game over for UI purposes
        introScreen.classList.add("hidden"); // Ensure intro is hidden
        displayHighScores(false); // False because no new game was played
      }

      function getHighScores() {
        const scoresJSON = localStorage.getItem("cyberpunkMazeRunnerScores");
        return scoresJSON ? JSON.parse(scoresJSON) : [];
      }

      function displayHighScores(isNewGameJustFinished) {
        const scores = getHighScores();

        if (isNewGameJustFinished) {
          const currentDateISO = new Date().toISOString().split("T")[0];
          scores.push({ date: currentDateISO, score: score });
          scores.sort((a, b) => b.score - a.score);
          localStorage.setItem(
            "cyberpunkMazeRunnerScores",
            JSON.stringify(scores)
          );

          finalScoreMessage.textContent = `Mazes Cleared: ${score}`;
          finalScoreMessage.style.display = "block";
          dailyLockoutMessage.style.display = "none";
          highScoreTitle.textContent = "Run Terminated";

          // Calculate and show rank message
          let rank = -1;
          const currentScoreEntryIndex = scores.findIndex(
            (s) => s.score === score && s.date === currentDateISO
          );
          if (currentScoreEntryIndex !== -1) {
            rank = 1;
            for (let i = 0; i < currentScoreEntryIndex; i++) {
              if (scores[i].score > scores[currentScoreEntryIndex].score) {
                // Compare with current entry's score
                rank++;
              }
            }
          } else if (score === 0) {
            rank = scores.filter((s) => s.score > 0).length + 1; // Rank after all non-zero scores
          }

          if (rank !== -1) {
            let suffix = "th";
            const j = rank % 10,
              k = rank % 100;
            if (j == 1 && k != 11) suffix = "st";
            if (j == 2 && k != 12) suffix = "nd";
            if (j == 3 && k != 13) suffix = "rd";
            rankMessage.textContent = `Congratulations! You placed ${rank}${suffix}!`;
            rankMessage.style.display = "block";
            rankMessage.style.opacity = "1"; // Make it visible for flashing
          } else {
            rankMessage.style.display = "none";
          }
        } else {
          // Viewing scores without a new game (already played today)
          finalScoreMessage.style.display = "none";
          rankMessage.style.display = "none";
          dailyLockoutMessage.style.display = "block";
          highScoreTitle.textContent = "Daily Run Completed";
        }

        highScoreList.innerHTML = "";
        const top10 = scores.slice(0, 10);
        let delay = 0;
        top10.forEach((s, index) => {
          const li = document.createElement("li");
          li.textContent = `${index + 1}. ${s.date} - Score: ${s.score}`;
          highScoreList.appendChild(li);
          setTimeout(() => {
            li.classList.add("visible");
            if (highScoreList.scrollHeight > highScoreList.clientHeight) {
              highScoreList.scrollTop = highScoreList.scrollHeight;
            }
          }, delay);
          delay += 150; // Slightly faster reveal
        });

        highScoreScreen.classList.remove("hidden");
        setTimeout(() => (highScoreScreen.style.opacity = "1"), 10);
      }

      startButton.addEventListener("click", () => {
        const lastPlayDate = localStorage.getItem(
          "cyberpunkMazeRunnerLastPlayDate"
        );
        const currentDateISO = new Date().toISOString().split("T")[0];

        introScreen.style.opacity = "0"; // Start fade out immediately

        if (lastPlayDate === currentDateISO) {
          // Already played today
          setTimeout(() => {
            introScreen.classList.add("hidden");
            showAlreadyPlayedScreen();
          }, 1000); // Wait for fade
        } else {
          // Haven't played today, start the game
          setTimeout(() => {
            introScreen.classList.add("hidden");
            startGame();
          }, 1000); // Wait for fade
        }
      });

      // Play Again button is removed, so no listener for it.

      window.addEventListener("resize", () => {
        resizeCanvas();
      });

      function init() {
        gameState = "intro";
        currentPalette = neonColorPalettes[0];
        resizeCanvas();
        introScreen.classList.remove("hidden");
        introScreen.style.opacity = "1";
        timerDisplay.textContent = `Time: ${String(
          Math.floor(GAME_DURATION / 60)
        ).padStart(2, "0")}:${String(GAME_DURATION % 60).padStart(2, "0")}`;
        scoreDisplay.textContent = `Score: 0`;

        // Hide elements on high score screen that might be visible from a previous state if not handled
        dailyLockoutMessage.style.display = "none";
        finalScoreMessage.style.display = "none";
        rankMessage.style.display = "none";
      }
      init();
    </script>
  </body>
</html>
