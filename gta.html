<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grand Theft Auto VI: Los Angeles Vibes</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Pricedown&display=swap'); 

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; user-select: none; touch-action: none; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD Elements */
        .hud-top-right {
            position: absolute;
            top: 20px; right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }

        .wanted-level {
            display: flex;
            gap: 5px;
        }
        
        .star {
            font-size: 24px;
            color: #333; 
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .star.active {
            color: #fff; 
            animation: pulse 1s infinite;
        }

        .cash {
            font-size: 36px;
            font-weight: 900;
            color: #85bb65;
            text-shadow: 2px 2px 0 #000;
            font-family: 'Courier New', monospace;
            transition: transform 0.2s;
        }
        .cash.update {
            color: #fff;
            transform: scale(1.2);
        }

        .hud-bottom-left {
            position: absolute;
            bottom: 30px; left: 30px;
            display: flex;
            align-items: flex-end;
            gap: 20px;
        }

        /* Minimap */
        .minimap-container {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.85);
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #minimap-canvas {
            width: 100%; height: 100%;
        }
        .player-blip {
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 14px solid #fff;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        /* Interaction Prompts */
        #interaction-prompt {
            position: absolute;
            top: 60%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            display: none;
            border-left: 4px solid #ff0055;
        }

        /* Mission Text */
        #mission-text {
            position: absolute;
            top: 20%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .mission-title {
            font-size: 40px;
            font-weight: 900;
            color: #ffaa00;
            text-shadow: 2px 2px 0 #000;
            text-transform: uppercase;
            margin: 0;
        }
        .mission-sub {
            font-size: 20px;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        .mission-passed {
            color: #85bb65 !important;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before { width: 2px; height: 10px; }
        #crosshair::after { width: 10px; height: 2px; }

        /* Touch Controls */
        #touch-controls {
            display: none; 
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            z-index: 500;
        }

        .touch-zone-left {
            position: absolute; bottom: 0; left: 0; width: 50%; height: 50%;
            pointer-events: auto;
        }
        .touch-zone-right {
            position: absolute; bottom: 0; right: 0; width: 50%; height: 50%;
            pointer-events: auto;
        }

        .joystick-base {
            position: absolute;
            bottom: 50px; left: 50px;
            width: 200px; height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
        }
        .joystick-stick {
            position: absolute;
            top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .touch-btn-group {
            position: absolute;
            bottom: 40px; right: 40px;
            display: flex;
            gap: 15px;
            align-items: flex-end;
            pointer-events: auto;
        }
        
        .touch-btn {
            width: 60px; height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex; justify-content: center; align-items: center;
            touch-action: manipulation;
            user-select: none;
        }
        .touch-btn:active { background: rgba(255, 0, 85, 0.5); transform: scale(0.95); }
        .btn-large { width: 70px; height: 70px; font-size: 30px; }

        /* Wasted Screen */
        #wasted-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s;
            z-index: 999;
        }
        #wasted-text {
            font-size: 120px;
            font-weight: 900;
            color: #cc0000;
            text-transform: uppercase;
            text-shadow: 0 0 30px rgba(0,0,0,0.8);
            letter-spacing: 5px;
            transform: scale(0.8);
            transition: transform 3s ease-out;
        }

        /* Instructions */
        .controls-hint {
            position: absolute;
            top: 20px; left: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            background: rgba(0,0,0,0.4);
            padding: 10px;
            border-radius: 8px;
            pointer-events: all;
        }

        @media (max-width: 800px) {
            .controls-hint { display: none; }
            .minimap-container { width: 120px; height: 120px; top: -150px; left: 0px; }
            .hud-bottom-left { bottom: auto; top: 100px; left: 20px; }
            #wasted-text { font-size: 60px; }
            #mission-text { top: 30%; }
        }

        /* City select modal */
        #city-modal {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at 20% 20%, rgba(255,0,85,0.1), transparent 35%),
                        radial-gradient(circle at 80% 30%, rgba(0,210,255,0.15), transparent 40%),
                        rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1200;
            color: #fff;
        }

        .city-modal-content {
            width: min(1100px, 90vw);
            background: linear-gradient(135deg, rgba(22,22,22,0.95), rgba(35,35,35,0.95));
            border: 2px solid rgba(255,255,255,0.08);
            border-radius: 18px;
            box-shadow: 0 25px 70px rgba(0,0,0,0.45);
            padding: 28px 28px 20px;
            backdrop-filter: blur(6px);
        }

        .city-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 18px;
        }

        .city-modal-header h2 {
            margin: 0;
            font-size: 26px;
            letter-spacing: 2px;
        }

        #city-start-btn {
            background: linear-gradient(90deg, #ff0055, #ff6a00);
            color: #fff;
            border: none;
            padding: 12px 18px;
            border-radius: 10px;
            font-weight: 800;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255,0,85,0.35);
        }

        #city-start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 36px rgba(255,0,85,0.45);
        }

        .city-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 14px;
        }

        .city-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 14px;
            cursor: pointer;
            transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .city-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 24px rgba(0,0,0,0.25);
        }

        .city-card.selected {
            border-color: #ff0055;
            box-shadow: 0 12px 26px rgba(255,0,85,0.25);
        }

        .city-card h3 {
            margin: 0 0 4px 0;
            letter-spacing: 1px;
        }

        .city-tag {
            font-size: 12px;
            opacity: 0.75;
        }

        .city-desc {
            font-size: 13px;
            line-height: 1.5;
            margin: 8px 0 12px 0;
            color: rgba(255,255,255,0.82);
        }

        .city-actions {
            display: flex;
            justify-content: flex-end;
        }

        .city-actions button {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        .city-actions button:hover {
            background: rgba(255,255,255,0.16);
            border-color: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>

<div id="city-modal">
    <div class="city-modal-content">
        <div class="city-modal-header">
            <h2>Select Your City</h2>
            <button id="city-start-btn">Start in Los Angeles</button>
        </div>
        <div class="city-grid" id="city-grid"></div>
    </div>
</div>

<!-- UI Layers -->
<div id="loading">
    <h1 style="color:white; font-style:italic; letter-spacing: 2px;">LOS ANGELES <span style="color:#ff0055">VIBES</span></h1>
    <div class="loader-bar"><div class="loader-fill" id="loader-fill"></div></div>
</div>

<div id="ui-layer">
    <div class="controls-hint">
        <b>WASD</b> Move/Drive | <b>SHIFT</b> Sprint/Nitro | <b>SPACE</b> Jump/Brake<br>
        <b>F</b> Enter/Exit Car | <b>CLICK</b> Shoot | <b>MOUSE</b> Look
    </div>

    <div id="mission-text">
        <h1 class="mission-title" id="mission-title-el">MISSION STARTED</h1>
        <div class="mission-sub" id="mission-sub-el">Go to the destination</div>
    </div>

    <div class="hud-top-right">
        <div class="wanted-level" id="wanted-container">
            <span class="star">‚òÖ</span><span class="star">‚òÖ</span><span class="star">‚òÖ</span><span class="star">‚òÖ</span><span class="star">‚òÖ</span>
        </div>
        <div class="cash" id="cash-display">$0</div>
    </div>

    <div id="interaction-prompt">Press F to Enter Vehicle</div>
    <div id="crosshair"></div>

    <div class="hud-bottom-left">
        <div class="minimap-container">
            <canvas id="minimap-canvas"></canvas>
            <div class="player-blip"></div>
        </div>
    </div>
</div>

<!-- Touch Controls Overlay -->
<div id="touch-controls">
    <div class="touch-zone-left" id="zone-joystick"></div>
    <div class="joystick-base" id="joystick-base">
        <div class="joystick-stick" id="joystick-stick"></div>
    </div>
    <div class="touch-zone-right" id="zone-look"></div>
    <div class="touch-btn-group">
        <div class="touch-btn" id="btn-car" style="background: rgba(0, 210, 255, 0.5);">üöó</div>
        <div class="touch-btn" id="btn-shoot" style="background: rgba(255, 0, 85, 0.5);">üî´</div>
        <div class="touch-btn" id="btn-jump">üõë</div>
        <div class="touch-btn btn-large" id="btn-sprint">üèÉ</div>
    </div>
</div>

<div id="wasted-screen">
    <div id="wasted-text">WASTED</div>
</div>

<!-- Game Script -->
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

// --- CONFIGURATION & CONSTANTS ---
const CITY_CONFIGS = {
    la: {
        name: 'Los Angeles',
        preview: 'Neon sunsets & wide freeways',
        description: 'Cruise neon-drenched boulevards, palm-lined freeways, and hazy sunsets straight out of an action flick.',
        colors: { skyTop: 0x4477bb, skyBottom: 0xffaa66, ground: 0x222222, neonPink: 0xff0055, neonBlue: 0x00d2ff },
        world: { worldSize: 1200, gridSize: 40, buildingDensity: 0.8 },
        vegetation: { trunkColor: 0x8B4513, leafColors: [0x228b22, 0x2ecc71, 0x6ab04c], maxTrees: 200 },
        missions: [
            { color: 0xff0000, start: { x: 5, z: 5 }, end: { x: -200, z: -200 } },
            { color: 0x00ff00, start: { x: -100, z: 100 }, end: { x: 100, z: -100 } },
            { color: 0x0000ff, start: { x: 150, z: -150 }, end: { x: -150, z: 50 } },
            { color: 0xffff00, start: { x: -200, z: -50 }, end: { x: 50, z: 200 } },
            { color: 0xff00ff, start: { x: 200, z: 200 }, end: { x: 0, z: 0 } }
        ]
    },
    nyc: {
        name: 'New York City',
        preview: 'Skyscrapers & steam vents',
        description: 'Tight grids, towering glass, and an endless buzz echoing up from the subway grates.',
        colors: { skyTop: 0x1c2b3f, skyBottom: 0xffd166, ground: 0x1b1b1b, neonPink: 0xff3366, neonBlue: 0x53a0fd },
        world: { worldSize: 1100, gridSize: 35, buildingDensity: 0.9 },
        vegetation: { trunkColor: 0x5d4037, leafColors: [0x1b5e20, 0x2e7d32, 0x558b2f], maxTrees: 160 },
        missions: [
            { color: 0x8be9fd, start: { x: -140, z: 140 }, end: { x: 140, z: -160 } },
            { color: 0xff79c6, start: { x: 120, z: -90 }, end: { x: -220, z: 60 } },
            { color: 0xffb86c, start: { x: 40, z: 200 }, end: { x: -40, z: -220 } }
        ]
    },
    miami: {
        name: 'Miami',
        preview: 'Art deco glow',
        description: 'Pastel art deco strips, turquoise waters, and humid midnight rides past neon palms.',
        colors: { skyTop: 0x2c7da0, skyBottom: 0xff8fa3, ground: 0x1e2a2f, neonPink: 0xff5f9e, neonBlue: 0x53f3ff },
        world: { worldSize: 1150, gridSize: 36, buildingDensity: 0.75 },
        vegetation: { trunkColor: 0xa76a3e, leafColors: [0x1abc9c, 0x16a085, 0x27ae60], maxTrees: 240 },
        missions: [
            { color: 0x00ffc3, start: { x: -80, z: -80 }, end: { x: 220, z: 120 } },
            { color: 0xff9ff3, start: { x: 160, z: 160 }, end: { x: -60, z: -200 } },
            { color: 0xffd166, start: { x: -200, z: 60 }, end: { x: 60, z: -220 } }
        ]
    },
    tokyo: {
        name: 'Tokyo',
        preview: 'Rain-slicked alleys',
        description: 'Blade-runner streets with towering billboards, lantern alleys, and reflections on wet asphalt.',
        colors: { skyTop: 0x0f1b2c, skyBottom: 0x7f5af0, ground: 0x111111, neonPink: 0xff4d6d, neonBlue: 0x5af8ff },
        world: { worldSize: 1050, gridSize: 32, buildingDensity: 0.95 },
        vegetation: { trunkColor: 0x4e342e, leafColors: [0x1f4068, 0x2d6cdf, 0x5f27cd], maxTrees: 140 },
        missions: [
            { color: 0x7c3aed, start: { x: -120, z: 40 }, end: { x: 220, z: -120 } },
            { color: 0xff5370, start: { x: 90, z: -200 }, end: { x: -140, z: 200 } },
            { color: 0x64ffda, start: { x: 200, z: 80 }, end: { x: -200, z: -80 } }
        ]
    },
    paris: {
        name: 'Paris',
        preview: 'Golden hours & stone',
        description: 'Cobblestone avenues, riverfront drives, and gold-lit monuments cutting through the mist.',
        colors: { skyTop: 0x3c4f76, skyBottom: 0xf2c57c, ground: 0x2b2620, neonPink: 0xff7f66, neonBlue: 0x9ddafc },
        world: { worldSize: 1000, gridSize: 34, buildingDensity: 0.7 },
        vegetation: { trunkColor: 0x8d6e63, leafColors: [0x556b2f, 0x6b8e23, 0x8f9779], maxTrees: 180 },
        missions: [
            { color: 0xf2c57c, start: { x: 40, z: 160 }, end: { x: -160, z: -60 } },
            { color: 0xff7f66, start: { x: -140, z: -120 }, end: { x: 200, z: 140 } }
        ]
    },
    london: {
        name: 'London',
        preview: 'Fog & fast lanes',
        description: 'Moody skies, Thames-side loops, and the glow of theater rows off the rain.',
        colors: { skyTop: 0x2a3140, skyBottom: 0xc4d6e5, ground: 0x1f2224, neonPink: 0xff4f81, neonBlue: 0x8cc7ff },
        world: { worldSize: 950, gridSize: 33, buildingDensity: 0.82 },
        vegetation: { trunkColor: 0x5d4037, leafColors: [0x2f4858, 0x376996, 0x7da0b8], maxTrees: 170 },
        missions: [
            { color: 0x8cc7ff, start: { x: -80, z: -150 }, end: { x: 160, z: 120 } },
            { color: 0xff4f81, start: { x: 150, z: 70 }, end: { x: -180, z: -40 } },
            { color: 0xe0c3fc, start: { x: 0, z: 200 }, end: { x: 0, z: -200 } }
        ]
    },
    rio: {
        name: 'Rio de Janeiro',
        preview: 'Beachfront chaos',
        description: 'Beachfront sweeps, jungle-backed hills, and carnival lights pouring into the avenues.',
        colors: { skyTop: 0x2f6b46, skyBottom: 0xffd166, ground: 0x1f2b24, neonPink: 0xff6b6b, neonBlue: 0x5ef3c7 },
        world: { worldSize: 1150, gridSize: 38, buildingDensity: 0.78 },
        vegetation: { trunkColor: 0x8b5a2b, leafColors: [0x2ecc71, 0x27ae60, 0x1e8449], maxTrees: 260 },
        missions: [
            { color: 0xff6b6b, start: { x: 200, z: -120 }, end: { x: -120, z: 200 } },
            { color: 0x5ef3c7, start: { x: -160, z: 80 }, end: { x: 160, z: -200 } },
            { color: 0xffd166, start: { x: 0, z: -200 }, end: { x: 0, z: 200 } }
        ]
    },
    dubai: {
        name: 'Dubai',
        preview: 'Chrome & desert',
        description: 'Glass spires in desert heat, desert motorways, and hyper-polished neon malls.',
        colors: { skyTop: 0x1f3a4a, skyBottom: 0xffc46b, ground: 0x1d1a17, neonPink: 0xff3c6f, neonBlue: 0x62d5ff },
        world: { worldSize: 1250, gridSize: 42, buildingDensity: 0.85 },
        vegetation: { trunkColor: 0xc39b77, leafColors: [0xc6ffdd, 0xfbd786, 0xf7797d], maxTrees: 120 },
        missions: [
            { color: 0xfbd786, start: { x: 180, z: 140 }, end: { x: -200, z: -140 } },
            { color: 0x62d5ff, start: { x: -60, z: -200 }, end: { x: 200, z: 60 } }
        ]
    },
    sydney: {
        name: 'Sydney',
        preview: 'Harbor lights',
        description: 'Harbor bridges, cliffside drives, and crisp ocean air under electric blues.',
        colors: { skyTop: 0x234a67, skyBottom: 0x99d6ff, ground: 0x1f2d33, neonPink: 0xff4c7f, neonBlue: 0x7cd5ff },
        world: { worldSize: 1080, gridSize: 36, buildingDensity: 0.76 },
        vegetation: { trunkColor: 0x6d4c41, leafColors: [0x1b9aaa, 0x61c0bf, 0xa8d0e6], maxTrees: 210 },
        missions: [
            { color: 0x7cd5ff, start: { x: -120, z: 120 }, end: { x: 160, z: -160 } },
            { color: 0xff4c7f, start: { x: 180, z: 0 }, end: { x: -180, z: 0 } }
        ]
    },
    chicago: {
        name: 'Chicago',
        preview: 'Windy grid',
        description: 'Steel bridges, elevated trains, and hard-edged grids pulsing with jazz neon.',
        colors: { skyTop: 0x1f3a52, skyBottom: 0xffb347, ground: 0x202428, neonPink: 0xff5c5c, neonBlue: 0x6cc0ff },
        world: { worldSize: 1020, gridSize: 34, buildingDensity: 0.88 },
        vegetation: { trunkColor: 0x5d4037, leafColors: [0x1b5e20, 0x2e7d32, 0x66bb6a], maxTrees: 175 },
        missions: [
            { color: 0x6cc0ff, start: { x: -150, z: -50 }, end: { x: 200, z: 100 } },
            { color: 0xff5c5c, start: { x: 100, z: 180 }, end: { x: -200, z: -120 } }
        ]
    }
};

const DEFAULT_CITY_KEY = 'la';

function getCityConfig(cityKey) {
    const base = CITY_CONFIGS[DEFAULT_CITY_KEY];
    const city = CITY_CONFIGS[cityKey] || base;
    return {
        ...base,
        ...city,
        colors: { ...base.colors, ...city.colors },
        world: { ...base.world, ...(city.world || {}) },
        vegetation: { ...base.vegetation, ...(city.vegetation || {}) },
        missions: city.missions || base.missions
    };
}

function colorToCss(color, alpha = 1) {
    const hex = color.toString(16).padStart(6, '0');
    if (alpha >= 1) return `#${hex}`;

    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

const defaultCity = getCityConfig(DEFAULT_CITY_KEY);

const CONFIG = {
    worldSize: defaultCity.world.worldSize,
    gridSize: defaultCity.world.gridSize,
    buildingDensity: defaultCity.world.buildingDensity,
    chunkSize: 50,
    gravity: 30,
    playerSpeed: 10,
    sprintSpeed: 18,
    carSpeed: 70,
    carTurnSpeed: 2.5,
    colors: { ...defaultCity.colors },
    vegetation: { ...defaultCity.vegetation },
    missions: defaultCity.missions
};

let activeCityConfig = defaultCity;

// --- GLOBAL VARIABLES ---
let scene, camera, renderer, clock;
let player, playerBodyParts = {};
let activeVehicle = null;
let cityBuildings = []; 
let physicsObjects = []; 
let vehicles = []; 
let pedestrians = [];
let tracerLines = [];
let input = {
    w: false,
    a: false,
    s: false,
    d: false,
    shift: false,
    space: false,
    drive: { x: 0, y: 0, magnitude: 0 },
    driveTarget: { x: 0, y: 0, magnitude: 0 }
};
let gameState = { wantedLevel: 0, cash: 0, isDriving: false, wasted: false, activeMission: null, selectedCity: DEFAULT_CITY_KEY };
let cameraAngles = { yaw: 0, pitch: 0.2 };
let touchLookState = { targetYawDelta: 0, targetPitchDelta: 0, velocityYaw: 0, velocityPitch: 0 };
let minimapCtx;
let raycaster = new THREE.Raycaster();
const dummy = new THREE.Object3D(); // For InstancedMesh updates

let selectedCityKey = DEFAULT_CITY_KEY;
let hasStarted = false;

function applyCityConfig(cityKey) {
    const resolvedKey = CITY_CONFIGS[cityKey] ? cityKey : DEFAULT_CITY_KEY;
    const city = getCityConfig(resolvedKey);
    selectedCityKey = resolvedKey;
    gameState.selectedCity = resolvedKey;
    activeCityConfig = city;
    CONFIG.worldSize = city.world.worldSize;
    CONFIG.gridSize = city.world.gridSize;
    CONFIG.buildingDensity = city.world.buildingDensity;
    CONFIG.vegetation = { ...city.vegetation };
    CONFIG.missions = city.missions;
    Object.assign(CONFIG.colors, city.colors);
    resetMissionState();
    document.title = `Grand Theft Auto VI: ${city.name} Vibes`;
    const loadingTitle = document.querySelector('#loading h1');
    if (loadingTitle) {
        loadingTitle.innerHTML = `${city.name.toUpperCase()} <span style="color:#ff0055">VIBES</span>`;
    }
}

function renderCityGrid() {
    const grid = document.getElementById('city-grid');
    if (!grid) return;
    grid.innerHTML = '';

    Object.entries(CITY_CONFIGS).forEach(([key, city]) => {
        const card = document.createElement('div');
        card.className = 'city-card';
        card.dataset.cityKey = key;
        card.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                <div>
                    <h3>${city.name}</h3>
                    <div class="city-tag">${city.preview}</div>
                </div>
                <span style="font-size:18px; opacity:0.85;">üåÜ</span>
            </div>
            <div class="city-desc">${city.description}</div>
            <div class="city-actions"><button data-city-key="${key}">Start Here</button></div>
        `;
        card.addEventListener('click', () => selectCity(key));
        card.querySelector('button').addEventListener('click', (e) => {
            e.stopPropagation();
            selectCity(key);
            startGame(key);
        });
        grid.appendChild(card);
    });
}

function selectCity(cityKey) {
    selectedCityKey = CITY_CONFIGS[cityKey] ? cityKey : DEFAULT_CITY_KEY;
    const grid = document.getElementById('city-grid');
    if (grid) {
        grid.querySelectorAll('.city-card').forEach(card => {
            card.classList.toggle('selected', card.dataset.cityKey === selectedCityKey);
        });
    }
    const city = CITY_CONFIGS[selectedCityKey];
    const startBtn = document.getElementById('city-start-btn');
    if (startBtn && city) {
        startBtn.textContent = `Start in ${city.name}`;
    }
}

function startGame(cityKey = selectedCityKey) {
    if (hasStarted) return;
    const chosenKey = CITY_CONFIGS[cityKey] ? cityKey : DEFAULT_CITY_KEY;
    applyCityConfig(chosenKey);
    const modal = document.getElementById('city-modal');
    if (modal) modal.style.display = 'none';
    const loader = document.getElementById('loading');
    if (loader) loader.style.display = 'flex';
    hasStarted = true;
    init();
}

// Mission Data
let missions = [];
let missionMarkersGroup;

function resetMissionState() {
    gameState.activeMission = null;
    missions = [];
    if (missionMarkersGroup && scene) {
        scene.remove(missionMarkersGroup);
    }
    missionMarkersGroup = null;
}

function getCityMissions(cityKey = gameState.selectedCity) {
    const key = CITY_CONFIGS[cityKey] ? cityKey : DEFAULT_CITY_KEY;
    const city = getCityConfig(key);
    return city.missions || [];
}

function setupCitySelection() {
    renderCityGrid();
    selectCity(DEFAULT_CITY_KEY);
    const startBtn = document.getElementById('city-start-btn');
    if (startBtn) startBtn.addEventListener('click', () => startGame(selectedCityKey));
    const loader = document.getElementById('loading');
    if (loader) loader.style.display = 'none';
    const modal = document.getElementById('city-modal');
    if (modal) modal.style.display = 'flex';
}

// --- INPUT MANAGER ---
function initInput() {
    // Keyboard
    document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if(key === 'w') input.w = true;
        if(key === 'a') input.a = true;
        if(key === 's') input.s = true;
        if(key === 'd') input.d = true;
        if(key === 'shift') input.shift = true;
        if(key === ' ') input.space = true;
        if(key === 'f') tryEnterExitVehicle();
    });
    document.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if(key === 'w') input.w = false;
        if(key === 'a') input.a = false;
        if(key === 's') input.s = false;
        if(key === 'd') input.d = false;
        if(key === 'shift') input.shift = false;
        if(key === ' ') input.space = false;
    });
    
    // Mouse
    document.addEventListener('mousedown', (e) => {
        if (e.target.closest('.touch-btn')) return; 
        if (e.button === 0 && !gameState.wasted) {
            if (!document.pointerLockElement && !isTouchDevice()) {
                document.body.requestPointerLock();
            } else {
                shootGun();
            }
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === document.body) {
            cameraAngles.yaw -= e.movementX * 0.002;
            cameraAngles.pitch += e.movementY * 0.002; 
            cameraAngles.pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, cameraAngles.pitch));
        }
    });

    if (isTouchDevice()) {
        initTouchControls();
    }
}

function isTouchDevice() {
    return (('ontouchstart' in window) ||
       (navigator.maxTouchPoints > 0) ||
       (navigator.msMaxTouchPoints > 0));
}

function initTouchControls() {
    document.getElementById('touch-controls').style.display = 'block';

    const joystickZone = document.getElementById('zone-joystick');
    const base = document.getElementById('joystick-base');
    const stick = document.getElementById('joystick-stick');
    const JOYSTICK_RADIUS = 90;
    const DEADZONE = 10;
    let joystickActive = false;
    let startX, startY;

    const setDriveTarget = (x, y, magnitude) => {
        input.driveTarget.x = x;
        input.driveTarget.y = y;
        input.driveTarget.magnitude = magnitude;
    };

    joystickZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        startX = touch.clientX;
        startY = touch.clientY;

        base.style.display = 'block';
        base.style.width = base.style.height = `${JOYSTICK_RADIUS * 2}px`;
        base.style.left = (startX - JOYSTICK_RADIUS) + 'px';
        base.style.top = (startY - JOYSTICK_RADIUS) + 'px';
        stick.style.transform = `translate(-50%, -50%)`;
        joystickActive = true;
        setDriveTarget(0, 0, 0);
    }, {passive: false});

    joystickZone.addEventListener('touchmove', (e) => {
        if (!joystickActive) return;
        e.preventDefault();
        const touch = e.changedTouches[0];

        let dx = touch.clientX - startX;
        let dy = touch.clientY - startY;
        const dist = Math.sqrt(dx*dx + dy*dy);

        const clampedDist = Math.min(dist, JOYSTICK_RADIUS);
        if (dist > 0) {
            dx = (dx / dist) * clampedDist;
            dy = (dy / dist) * clampedDist;
        }

        const hasInput = clampedDist > DEADZONE;
        const magnitude = hasInput ? (clampedDist - DEADZONE) / (JOYSTICK_RADIUS - DEADZONE) : 0;
        const normX = hasInput ? (dx / clampedDist) : 0;
        const normY = hasInput ? (dy / clampedDist) : 0;

        setDriveTarget(normX * magnitude, normY * magnitude, magnitude);

        stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

        input.w = normY < -0.25;
        input.s = normY > 0.25;
        input.a = normX < -0.25;
        input.d = normX > 0.25;

    }, {passive: false});

    const endJoystick = (e) => {
        e.preventDefault();
        joystickActive = false;
        base.style.display = 'none';
        input.w = input.s = input.a = input.d = false;
        setDriveTarget(0, 0, 0);
    };

    joystickZone.addEventListener('touchend', endJoystick);
    joystickZone.addEventListener('touchcancel', endJoystick);

    const lookZone = document.getElementById('zone-look');
    let lastLookX, lastLookY;
    const LOOK_YAW_SENSITIVITY = 0.007;
    const LOOK_PITCH_SENSITIVITY = 0.0055;
    const LOOK_DELTA_CAP = 50;
    const LOOK_FILTER_STRENGTH = 0.45;
    const LOOK_INERTIA_DECAY = 0.9;
    const MOBILE_LOOK_MULTIPLIER = 1.15;

    lookZone.addEventListener('touchstart', (e) => {
        const touch = e.changedTouches[0];
        lastLookX = touch.clientX;
        lastLookY = touch.clientY;
    });

    lookZone.addEventListener('touchmove', (e) => {
        const touch = e.changedTouches[0];
        const dx = THREE.MathUtils.clamp(touch.clientX - lastLookX, -LOOK_DELTA_CAP, LOOK_DELTA_CAP);
        const dy = THREE.MathUtils.clamp(touch.clientY - lastLookY, -LOOK_DELTA_CAP, LOOK_DELTA_CAP);

        const yawDelta = -dx * LOOK_YAW_SENSITIVITY * MOBILE_LOOK_MULTIPLIER;
        const pitchDelta = dy * LOOK_PITCH_SENSITIVITY * MOBILE_LOOK_MULTIPLIER;

        touchLookState.targetYawDelta = THREE.MathUtils.lerp(touchLookState.targetYawDelta, yawDelta, LOOK_FILTER_STRENGTH);
        touchLookState.targetPitchDelta = THREE.MathUtils.lerp(touchLookState.targetPitchDelta, pitchDelta, LOOK_FILTER_STRENGTH);
        touchLookState.targetYawDelta *= LOOK_INERTIA_DECAY;
        touchLookState.targetPitchDelta *= LOOK_INERTIA_DECAY;

        lastLookX = touch.clientX;
        lastLookY = touch.clientY;
    });

    const clearLook = () => {
        lastLookX = undefined;
        lastLookY = undefined;
    };

    lookZone.addEventListener('touchend', clearLook);
    lookZone.addEventListener('touchcancel', clearLook);

    const btnMap = [
        { id: 'btn-sprint', key: 'shift' },
        { id: 'btn-jump', key: 'space' }
    ];

    btnMap.forEach(b => {
        const el = document.getElementById(b.id);
        el.addEventListener('touchstart', (e) => { e.preventDefault(); input[b.key] = true; });
        el.addEventListener('touchend', (e) => { e.preventDefault(); input[b.key] = false; });
    });

    const btnCar = document.getElementById('btn-car');
    btnCar.addEventListener('touchstart', (e) => {
        e.preventDefault();
        tryEnterExitVehicle();
    });

    const btnShoot = document.getElementById('btn-shoot');
    btnShoot.addEventListener('touchstart', (e) => {
        e.preventDefault();
        shootGun();
    });
}

function updateTouchInput(dt) {
    if (!isTouchDevice()) return;

    const smoothing = Math.min(1, dt * 12);

    const lookSmoothing = Math.min(1, dt * 18);
    const lookInertia = Math.max(0, 1 - dt * 10);

    input.drive.x = THREE.MathUtils.lerp(input.drive.x, input.driveTarget.x, smoothing);
    input.drive.y = THREE.MathUtils.lerp(input.drive.y, input.driveTarget.y, smoothing);
    input.drive.magnitude = THREE.MathUtils.lerp(input.drive.magnitude, input.driveTarget.magnitude, smoothing);

    touchLookState.velocityYaw = THREE.MathUtils.lerp(touchLookState.velocityYaw, touchLookState.targetYawDelta, lookSmoothing);
    touchLookState.velocityPitch = THREE.MathUtils.lerp(touchLookState.velocityPitch, touchLookState.targetPitchDelta, lookSmoothing);

    cameraAngles.yaw += touchLookState.velocityYaw;
    cameraAngles.pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, cameraAngles.pitch + touchLookState.velocityPitch));

    touchLookState.targetYawDelta *= lookInertia;
    touchLookState.targetPitchDelta *= lookInertia;

    if (Math.abs(input.drive.x) < 0.001) input.drive.x = 0;
    if (Math.abs(input.drive.y) < 0.001) input.drive.y = 0;
    if (input.drive.magnitude < 0.001) input.drive.magnitude = 0;
}

// --- MISSION SYSTEM ---
function initMissions() {
    if (missionMarkersGroup) {
        scene.remove(missionMarkersGroup);
    }
    gameState.activeMission = null;
    missions = [];
    missionMarkersGroup = new THREE.Group();
    scene.add(missionMarkersGroup);

    const missionConfigs = getCityMissions().map(cfg => ({
        color: cfg.color,
        start: { ...cfg.start },
        end: { ...cfg.end }
    }));

    const cityColors = activeCityConfig.colors || {};
    const destinationColor = cityColors.neonBlue ?? 0xffff00;

    missionConfigs.forEach((cfg, index) => {
        // Validate Start Position
        while (checkCollisionWithBuildings(cfg.start.x, cfg.start.z, 4)) {
            cfg.start.x += 5; // Shift until clear
        }
        // Validate End Position
        while (checkCollisionWithBuildings(cfg.end.x, cfg.end.z, 4)) {
            cfg.end.x += 5;
        }

        const markerGeo = new THREE.CylinderGeometry(2, 2, 0.2, 32);
        const startColor = cfg.color ?? cityColors.neonPink ?? 0xff0055;
        const markerMat = new THREE.MeshBasicMaterial({ color: startColor, transparent: true, opacity: 0.6 });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.set(cfg.start.x, 0.2, cfg.start.z);
        missionMarkersGroup.add(marker);

        const destGeo = new THREE.CylinderGeometry(3, 3, 200, 32);
        const destMat = new THREE.MeshBasicMaterial({ color: destinationColor, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const destMarker = new THREE.Mesh(destGeo, destMat);
        destMarker.position.set(cfg.end.x, 100, cfg.end.z);
        destMarker.visible = false;
        missionMarkersGroup.add(destMarker);

        const ringGeo = new THREE.RingGeometry(3, 4, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: destinationColor, side: THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI/2;
        ring.position.y = -100 + 0.5;
        destMarker.add(ring);

        missions.push({
            id: index,
            active: false,
            completed: false,
            startPos: new THREE.Vector3(cfg.start.x, 0, cfg.start.z),
            endPos: new THREE.Vector3(cfg.end.x, 0, cfg.end.z),
            startMesh: marker,
            endMesh: destMarker,
            color: startColor
        });
    });
}

function updateMissions() {
    if (gameState.activeMission === null) {
        const pPos = gameState.isDriving ? activeVehicle.mesh.position : player.mesh.position;
        
        missions.forEach(m => {
            if (!m.completed && !m.active) {
                m.startMesh.rotation.y += 0.02;
                if (pPos.distanceTo(m.startPos) < 3) {
                    startMission(m);
                }
            }
        });
    } else {
        const m = missions[gameState.activeMission];
        const pPos = gameState.isDriving ? activeVehicle.mesh.position : player.mesh.position;
        
        const dist = Math.sqrt(Math.pow(pPos.x - m.endPos.x, 2) + Math.pow(pPos.z - m.endPos.z, 2));
        
        if (dist < 6) {
            completeMission(m);
        }
    }
}

function startMission(mission) {
    gameState.activeMission = mission.id;
    mission.active = true;
    mission.startMesh.visible = false;
    mission.endMesh.visible = true;
    showMissionText("MISSION STARTED", "Follow the yellow route", false);
}

function completeMission(mission) {
    gameState.activeMission = null;
    mission.active = false;
    mission.completed = true;
    mission.endMesh.visible = false;
    addCash(1000);
    showMissionText("MISSION PASSED", "+ $1000", true);
}

function showMissionText(title, sub, isPass) {
    const el = document.getElementById('mission-text');
    const tEl = document.getElementById('mission-title-el');
    const sEl = document.getElementById('mission-sub-el');
    tEl.innerText = title;
    tEl.className = isPass ? "mission-title mission-passed" : "mission-title";
    sEl.innerText = sub;
    el.style.opacity = 1;
    setTimeout(() => { el.style.opacity = 0; }, 4000);
}

function addCash(amount) {
    gameState.cash += amount;
    const el = document.getElementById('cash-display');
    el.innerText = '$' + gameState.cash;
    el.classList.add('update');
    setTimeout(() => el.classList.remove('update'), 200);
}

// --- SHOOTING ---
function knockDownPed(ped) {
    if (ped && !ped.isDead) {
        ped.isDead = true;
        // Ragdoll visual (fall over)
        ped.mesh.rotation.x = -Math.PI / 2;
        ped.mesh.position.y = 0.5;
    }
}

function shootGun() {
    if(gameState.isDriving) return;

    // Flash
    const flash = new THREE.PointLight(0xffffaa, 5, 5);
    flash.position.copy(playerBodyParts.gun.getWorldPosition(new THREE.Vector3()));
    scene.add(flash);
    setTimeout(() => scene.remove(flash), 50);

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
    
    // Check Vehicles
    const vehicleMeshes = vehicles.map(v => v.mesh);
    const intersectsV = raycaster.intersectObjects(vehicleMeshes, true);

    // Check Pedestrians
    const pedMeshes = pedestrians.map(p => p.mesh);
    const intersectsP = raycaster.intersectObjects(pedMeshes, true);

    let endPoint = raycaster.ray.direction.clone().multiplyScalar(100).add(raycaster.ray.origin);
    
    // Check nearest hit
    let nearestDist = 1000;

    if (intersectsV.length > 0 && intersectsV[0].distance < nearestDist) {
        nearestDist = intersectsV[0].distance;
        endPoint = intersectsV[0].point;
        
        let obj = intersectsV[0].object;
        while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
        
        const veh = vehicles.find(v => v.mesh === obj);
        if(veh) {
            veh.stopped = true; // Disable AI
            veh.mesh.children.forEach(c => {
                if(c.material && c.material.color) c.material.color.setHex(0x555555); // Darken
            });
            const smoke = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:0x555555}));
            smoke.position.copy(intersectsV[0].point);
            scene.add(smoke);
        }
    }

    if (intersectsP.length > 0 && intersectsP[0].distance < nearestDist) {
        nearestDist = intersectsP[0].distance;
        endPoint = intersectsP[0].point;
        
        let obj = intersectsP[0].object;
        while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
        
        const ped = pedestrians.find(p => p.mesh === obj);
        knockDownPed(ped);
    }

    // Tracer
    const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
    const points = [];
    points.push(playerBodyParts.gun.getWorldPosition(new THREE.Vector3()));
    points.push(endPoint);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geometry, material);
    scene.add(line);
    tracerLines.push({ mesh: line, life: 0.1 });
}

// --- CAMERA SYSTEM ---
function updateCamera(dt) {
    let targetObj = gameState.isDriving ? activeVehicle.mesh : player.mesh;
    let targetPos = targetObj.position.clone();

    if(gameState.isDriving) {
        cameraAngles.pitch = Math.max(-0.5, Math.min(1.0, cameraAngles.pitch)); 
        
        let hDist = 12; 
        let vDist = 4;
        
        let cx = targetPos.x - Math.sin(cameraAngles.yaw) * hDist * Math.cos(cameraAngles.pitch);
        let cz = targetPos.z - Math.cos(cameraAngles.yaw) * hDist * Math.cos(cameraAngles.pitch);
        let cy = targetPos.y + Math.sin(cameraAngles.pitch) * hDist + 2;

        if(cy < 0.5) cy = 0.5; 

        camera.position.lerp(new THREE.Vector3(cx, cy, cz), dt * 10);
        camera.lookAt(targetPos.clone().add(new THREE.Vector3(0, 1, 0)));

    } else {
        targetPos.y += 1.5;
        let hDist = 3.5;
        let cx = targetPos.x - Math.sin(cameraAngles.yaw) * hDist * Math.cos(cameraAngles.pitch);
        let cz = targetPos.z - Math.cos(cameraAngles.yaw) * hDist * Math.cos(cameraAngles.pitch);
        let cy = targetPos.y + Math.sin(cameraAngles.pitch) * hDist + 0.5;
        
        if(cy < 0.5) cy = 0.5;
        
        let rightOffset = new THREE.Vector3(Math.cos(cameraAngles.yaw), 0, -Math.sin(cameraAngles.yaw)).multiplyScalar(0.8);
        let camPos = new THREE.Vector3(cx, cy, cz).add(rightOffset);

        camera.position.lerp(camPos, dt * 15);
        camera.lookAt(targetPos.clone().add(rightOffset));
    }
}

// --- INIT ---
function init() {
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // PERFORMANCE FIX
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(CONFIG.colors.skyTop, 0.005);
    scene.background = new THREE.Color(CONFIG.colors.skyTop);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    clock = new THREE.Clock();

    const hemiLight = new THREE.HemisphereLight(CONFIG.colors.skyTop, CONFIG.colors.skyBottom, 0.9);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffdd88, 2.5);
    dirLight.position.set(-100, 100, -100);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024; // PERFORMANCE FIX
    dirLight.shadow.mapSize.height = 1024; // PERFORMANCE FIX
    dirLight.shadow.camera.left = -200;
    dirLight.shadow.camera.right = 200;
    dirLight.shadow.camera.top = 200;
    dirLight.shadow.camera.bottom = -200;
    scene.add(dirLight);

    generateCity(activeCityConfig);
    initMissions();
    createPlayer();
    
    // Player's starting car
    const startCar = createVehicle(0, 0.5, -8, CONFIG.colors.neonPink, false); // false = not traffic (has lights)
    
    initTraffic();
    initPedestrians();
    initInput();
    initMinimap();

    document.getElementById('loading').style.display = 'none';
    animate();
}

function createBuildingTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#444'; ctx.fillRect(0,0,64,64);
    ctx.fillStyle = '#111'; 
    for(let y=4; y<64; y+=8) {
        for(let x=4; x<64; x+=8) {
            ctx.fillStyle = Math.random() > 0.6 ? '#ffeedd' : '#111';
            ctx.fillRect(x, y, 4, 6);
        }
    }
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.minFilter = THREE.NearestFilter;
    tex.magFilter = THREE.NearestFilter;
    return tex;
}

function createRoadTexture(city) {
    const { world: { worldSize, gridSize }, colors } = city;
    const canvasSize = 2048;
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = canvasSize;
    const ctx = canvas.getContext('2d');

    const worldScale = canvasSize / worldSize;
    const halfSize = canvasSize / 2;
    const roadWidth = Math.max(12, gridSize * 0.35) * worldScale;

    const baseGround = new THREE.Color(colors.ground || 0x1b1b1b);
    ctx.fillStyle = `#${baseGround.getHexString()}`;
    ctx.fillRect(0, 0, canvasSize, canvasSize);

    const roadColor = `#${baseGround.clone().multiplyScalar(0.85).getHexString()}`;
    const laneColor = `#${new THREE.Color(colors.neonBlue || 0xe8e8e8).offsetHSL(0, -0.05, 0.15).getHexString()}`;
    const dash = 20 * worldScale;
    const gap = 14 * worldScale;
    const lineWidth = Math.max(2, 3 * worldScale);

    const roadCoords = [];
    const halfExtent = (worldSize / 2) - gridSize;
    for(let c = -halfExtent; c <= halfExtent; c += gridSize) roadCoords.push(c);

    roadCoords.forEach(coord => {
        const center = halfSize + coord * worldScale;

        // Horizontal roads (east-west)
        ctx.fillStyle = roadColor;
        ctx.fillRect(0, center - roadWidth / 2, canvasSize, roadWidth);

        // Vertical roads (north-south)
        ctx.fillRect(center - roadWidth / 2, 0, roadWidth, canvasSize);

        // Lane markings for horizontal road
        ctx.strokeStyle = laneColor;
        ctx.lineWidth = lineWidth;
        ctx.setLineDash([dash, gap]);
        ctx.beginPath();
        ctx.moveTo(0, center);
        ctx.lineTo(canvasSize, center);
        ctx.stroke();

        // Lane markings for vertical road
        ctx.beginPath();
        ctx.moveTo(center, 0);
        ctx.lineTo(center, canvasSize);
        ctx.stroke();
    });

    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.anisotropy = 8;
    tex.needsUpdate = true;
    return tex;
}

function generateCity(cityConfig = activeCityConfig || defaultCity) {
    const city = cityConfig || defaultCity;
    const { world: { worldSize, gridSize, buildingDensity }, colors, vegetation } = city;

    const roadTexture = createRoadTexture(city);
    const roadMat = new THREE.MeshStandardMaterial({ map: roadTexture, roughness: 0.8, color: colors.ground || 0x222222 });
    // PERFORMANCE FIX: Single shared material and texture for all buildings
    const buildingTex = createBuildingTexture();
    const buildingMat = new THREE.MeshStandardMaterial({ map: buildingTex, roughness: 0.3 });

    const groundGeo = new THREE.PlaneGeometry(worldSize, worldSize);
    const ground = new THREE.Mesh(groundGeo, roadMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    physicsObjects.push({ type: 'ground', y: 0 });

    const streetWidth = Math.max(12, gridSize * 0.35);
    const halfExtent = (worldSize / 2) - gridSize;

    // Building Instancing Setup
    const buildingBoxGeo = new THREE.BoxGeometry(1, 1, 1);
    const approxPlots = Math.floor((worldSize / gridSize) ** 2 * buildingDensity);
    const maxBuildings = Math.min(800, Math.max(300, approxPlots));
    const buildingMesh = new THREE.InstancedMesh(buildingBoxGeo, buildingMat, maxBuildings);
    buildingMesh.castShadow = true;
    buildingMesh.receiveShadow = true;
    scene.add(buildingMesh);
    let buildingIdx = 0;

    // Neon Trims Instancing
    const trimGeo = new THREE.BoxGeometry(1, 0.5, 1);
    const trimMat = new THREE.MeshBasicMaterial({ color: colors.neonPink });
    const trimMesh = new THREE.InstancedMesh(trimGeo, trimMat, maxBuildings);
    scene.add(trimMesh);
    let trimIdx = 0;

    for (let x = -halfExtent; x <= halfExtent; x += gridSize) {
        for (let z = -halfExtent; z <= halfExtent; z += gridSize) {
            let distToCenter = Math.sqrt(x*x + z*z);
            if (Math.random() > buildingDensity && distToCenter > gridSize * 1.25) continue;
            if (Math.abs(x) < gridSize * 0.5 && Math.abs(z) < gridSize * 0.5) continue;

            const baseHeight = Math.max(5, gridSize * 0.2);
            const variability = Math.max(15, gridSize * 0.9);
            let height = baseHeight + Math.random() * variability;
            let width = Math.max(6, gridSize - streetWidth);
            if(distToCenter < gridSize * 3) height = Math.max(baseHeight * 2, gridSize * 1.2) + Math.random() * Math.max(80, gridSize * 2);

            if (buildingIdx < maxBuildings) {
                dummy.position.set(x, height / 2, z);
                dummy.rotation.set(0, 0, 0);
                dummy.scale.set(width, height, width);
                dummy.updateMatrix();
                buildingMesh.setMatrixAt(buildingIdx++, dummy.matrix);

                // Neon Trim for tall buildings
                if (height > 40 && trimIdx < maxBuildings) {
                    dummy.position.set(x, height - 2, z);
                    dummy.scale.set(width + 0.2, 1, width + 0.2);
                    dummy.updateMatrix();
                    trimMesh.setMatrixAt(trimIdx++, dummy.matrix);
                }

                cityBuildings.push({ 
                    x: x, z: z, w: width, d: width,
                    minX: x - width/2, maxX: x + width/2,
                    minZ: z - width/2, maxZ: z + width/2
                });
            }
        }
    }
    buildingMesh.instanceMatrix.needsUpdate = true;
    trimMesh.instanceMatrix.needsUpdate = true;
    
    // Tree Instancing Setup
    const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 6, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color: vegetation.trunkColor || colors.ground || 0x8B4513 });
    const leavesGeo = new THREE.ConeGeometry(2.5, 1, 6);
    const leafPalette = (vegetation.leafColors && vegetation.leafColors.length)
        ? vegetation.leafColors
        : [colors.neonBlue, colors.neonPink, colors.ground].filter(Boolean);
    const leavesMat = new THREE.MeshStandardMaterial({ color: leafPalette[0] || 0x228b22, vertexColors: true });

    const maxTrees = vegetation.maxTrees || 200;
    const trunkMeshInstanced = new THREE.InstancedMesh(trunkGeo, trunkMat, maxTrees);
    const leavesMeshInstanced = new THREE.InstancedMesh(leavesGeo, leavesMat, maxTrees);
    leavesMeshInstanced.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxTrees * 3), 3);
    trunkMeshInstanced.castShadow = true;
    scene.add(trunkMeshInstanced);
    scene.add(leavesMeshInstanced);

    let treeIdx = 0;
    for(let i=0; i<maxTrees; i++) {
        let x = (Math.random() - 0.5) * worldSize * 0.6;
        let z = (Math.random() - 0.5) * worldSize * 0.6;
        if(checkCollisionWithBuildings(x, z, 2)) continue;
        
        dummy.position.set(x, 3, z);
        dummy.rotation.set(0, 0, 0);
        dummy.scale.set(1, 1, 1);
        dummy.updateMatrix();
        trunkMeshInstanced.setMatrixAt(treeIdx, dummy.matrix);
        
        dummy.position.set(x, 6, z); // Leaves higher
        dummy.updateMatrix();
        leavesMeshInstanced.setMatrixAt(treeIdx, dummy.matrix);
        const leafColor = leafPalette[Math.floor(Math.random() * leafPalette.length)] || leafPalette[0];
        leavesMeshInstanced.setColorAt(treeIdx, new THREE.Color(leafColor));
        treeIdx++;
    }
    trunkMeshInstanced.instanceMatrix.needsUpdate = true;
    leavesMeshInstanced.instanceMatrix.needsUpdate = true;
    if (leavesMeshInstanced.instanceColor) leavesMeshInstanced.instanceColor.needsUpdate = true;
}

function checkCollisionWithBuildings(x, z, radius) {
    for(let b of cityBuildings) {
        if (x + radius > b.minX && x - radius < b.maxX && z + radius > b.minZ && z - radius < b.maxZ) return true;
    }
    return false;
}

function resolveBuildingCollision(pos, radius, velocity) {
    for(let b of cityBuildings) {
        if (pos.x + radius > b.minX && pos.x - radius < b.maxX && pos.z + radius > b.minZ && pos.z - radius < b.maxZ) {
            let overlapX = Math.min(pos.x + radius - b.minX, b.maxX - (pos.x - radius));
            let overlapZ = Math.min(pos.z + radius - b.minZ, b.maxZ - (pos.z - radius));
            if (overlapX < overlapZ) {
                if (pos.x < b.x) pos.x = b.minX - radius - 0.01;
                else pos.x = b.maxX + radius + 0.01;
                velocity.x = -velocity.x * 0.5; 
            } else {
                if (pos.z < b.z) pos.z = b.minZ - radius - 0.01;
                else pos.z = b.maxZ + radius + 0.01;
                velocity.z = -velocity.z * 0.5; 
            }
        }
    }
}

// --- VEHICLE SYSTEM ---
function createVehicle(x, y, z, color, isTraffic = false) { // Added isTraffic param
    const group = new THREE.Group();
    
    const bodyGeo = new THREE.BoxGeometry(2.2, 1, 4.5);
    const bodyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.7 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.8;
    body.castShadow = true;
    group.add(body);

    const cabinGeo = new THREE.BoxGeometry(1.8, 0.7, 2.5);
    const cabinMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1 }); 
    const cabin = new THREE.Mesh(cabinGeo, cabinMat);
    cabin.position.set(0, 1.6, -0.2);
    group.add(cabin);

    const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    wheelGeo.rotateZ(Math.PI / 2);
    const w1 = new THREE.Mesh(wheelGeo, wheelMat); w1.position.set(1.1, 0.4, 1.5); group.add(w1);
    const w2 = new THREE.Mesh(wheelGeo, wheelMat); w2.position.set(-1.1, 0.4, 1.5); group.add(w2);
    const w3 = new THREE.Mesh(wheelGeo, wheelMat); w3.position.set(1.1, 0.4, -1.5); group.add(w3);
    const w4 = new THREE.Mesh(wheelGeo, wheelMat); w4.position.set(-1.1, 0.4, -1.5); group.add(w4);

    const hlGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
    const hlMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
    const hlL = new THREE.Mesh(hlGeo, hlMat); hlL.position.set(0.8, 0.8, 2.3); group.add(hlL);
    const hlR = new THREE.Mesh(hlGeo, hlMat); hlR.position.set(-0.8, 0.8, 2.3); group.add(hlR);

    // PERFORMANCE FIX: Only add lights for player car
    if (!isTraffic) {
        const spotL = new THREE.SpotLight(0xffffee, 5, 40, 0.5, 0.5, 1);
        spotL.position.set(0.8, 0.8, 2.3);
        spotL.target.position.set(0.8, 0, 10);
        group.add(spotL); group.add(spotL.target);
        const spotR = new THREE.SpotLight(0xffffee, 5, 40, 0.5, 0.5, 1);
        spotR.position.set(-0.8, 0.8, 2.3);
        spotR.target.position.set(-0.8, 0, 10);
        group.add(spotR); group.add(spotR.target);
    }

    group.position.set(x, y, z);
    scene.add(group);

    const vehicle = {
        mesh: group,
        speed: 0,
        steering: 0,
        velocity: new THREE.Vector3(),
        radius: 1.5,
        stopped: false,
        isTraffic: isTraffic,
        dir: 1, 
        axis: 'z' 
    };
    
    vehicles.push(vehicle);
    return vehicle;
}

function initTraffic() {
    const carColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, CONFIG.colors.neonBlue];
    const roadCoords = [];
    const halfExtent = (CONFIG.worldSize / 2) - CONFIG.gridSize;
    for(let c = -halfExtent; c <= halfExtent; c += CONFIG.gridSize) roadCoords.push(c);

    for (let i = 0; i < 30; i++) {
        let isXRoad = Math.random() > 0.5;
        let roadIndex = Math.floor(Math.random() * roadCoords.length);
        let laneCoord = roadCoords[roadIndex];
        let travelCoord = (Math.random() * CONFIG.worldSize) - (CONFIG.worldSize / 2);

        let direction = Math.random() > 0.5 ? 1 : -1;
        laneCoord += (direction * Math.max(3.5, CONFIG.gridSize * 0.1));

        let x, z;
        if(isXRoad) {
            z = laneCoord;
            x = travelCoord;
        } else {
            x = laneCoord;
            z = travelCoord;
        }

        const veh = createVehicle(x, 0.5, z, carColors[Math.floor(Math.random() * carColors.length)], true); // true = is traffic
        veh.axis = isXRoad ? 'x' : 'z';
        veh.dir = direction;
        veh.mesh.rotation.y = isXRoad ? (direction > 0 ? Math.PI/2 : -Math.PI/2) : (direction > 0 ? 0 : Math.PI);
    }
}

function updateVehicles(dt) {
    vehicles.forEach(v => {
        if (v === activeVehicle) {
            // Player Control
            const hasDriveVector = input.drive.magnitude > 0.01;
            const forwardInput = hasDriveVector ? Math.max(0, -input.drive.y) : (input.w ? 1 : 0);
            const reverseInput = hasDriveVector ? Math.max(0, input.drive.y) : (input.s ? 1 : 0);
            const turn = hasDriveVector ? THREE.MathUtils.clamp(-input.drive.x, -1, 1) : (input.a ? 1 : (input.d ? -1 : 0));
            const brake = input.space;
            const nitro = input.shift;

            let maxSpeed = CONFIG.carSpeed * (nitro ? 1.5 : 1);
            if (forwardInput > 0) v.speed += dt * 30 * forwardInput;
            else if (reverseInput > 0) v.speed -= dt * 20 * reverseInput;
            else v.speed *= 0.98;

            if (brake) v.speed *= 0.92;
            v.speed = Math.max(Math.min(v.speed, maxSpeed), -maxSpeed / 2);

            if (Math.abs(v.speed) > 1) {
                v.steering = THREE.MathUtils.lerp(v.steering, turn * CONFIG.carTurnSpeed, dt * 5);
                let dir = v.speed > 0 ? 1 : -1;
                v.mesh.rotateY(v.steering * dt * dir);
            }
        } else if (v.isTraffic && !v.stopped) {
            // AI Control
            v.speed = 20; // Cruising speed
            // Simple lane following
            if(v.axis === 'x') {
                v.mesh.position.x += v.dir * v.speed * dt;
                if(v.mesh.position.x > 450) v.mesh.position.x = -450;
                if(v.mesh.position.x < -450) v.mesh.position.x = 450;
            } else {
                v.mesh.position.z += v.dir * v.speed * dt;
                if(v.mesh.position.z > 450) v.mesh.position.z = -450;
                if(v.mesh.position.z < -450) v.mesh.position.z = 450;
            }
            return; // Skip physics for AI
        } else {
            // Friction for stopped/empty cars
            v.speed *= 0.95;
            if(Math.abs(v.speed) < 0.1) v.speed = 0;
        }

        // Apply physics movement
        if (!v.isTraffic || v === activeVehicle || v.stopped) {
            let moveVec = new THREE.Vector3(0,0,1).applyQuaternion(v.mesh.quaternion).multiplyScalar(v.speed * dt);
            let nextPos = v.mesh.position.clone().add(moveVec);
            resolveBuildingCollision(nextPos, v.radius, v.velocity);
            v.mesh.position.copy(nextPos);
            v.mesh.children[0].rotation.z = THREE.MathUtils.lerp(v.mesh.children[0].rotation.z, -v.steering * 0.05, dt * 5);
        }

        if (v === activeVehicle && Math.abs(v.speed) > 2) {
            pedestrians.forEach(ped => {
                if (ped.isDead) return;
                const dist = ped.mesh.position.distanceTo(v.mesh.position);
                const pedRadius = ped.radius ?? 0.6;
                if (dist < v.radius + pedRadius) {
                    knockDownPed(ped);
                }
            });
        }
    });
}

function tryEnterExitVehicle() {
    if(gameState.isDriving) {
        gameState.isDriving = false;
        // Exit active vehicle
        const exitOffset = new THREE.Vector3(3, 0, 0).applyQuaternion(activeVehicle.mesh.quaternion);
        player.mesh.position.copy(activeVehicle.mesh.position).add(exitOffset);
        player.mesh.position.y = 1;
        player.velocity.set(0,0,0);
        
        // Reset vehicle state (it becomes just an object)
        if (activeVehicle.isTraffic) activeVehicle.stopped = true; // Stolen cars don't resume AI
        activeVehicle = null;
        
        if (!isTouchDevice()) document.body.requestPointerLock();
    } else {
        // Find nearest car
        let nearest = null;
        let minDst = 100;
        vehicles.forEach(v => {
            let dst = player.mesh.position.distanceTo(v.mesh.position);
            if(dst < 6 && dst < minDst) {
                minDst = dst;
                nearest = v;
            }
        });

        if (nearest) {
            gameState.isDriving = true;
            activeVehicle = nearest;
            activeVehicle.stopped = false; // Player takes control
            
            // Fix: Hide Prompt immediately
            document.getElementById('interaction-prompt').style.display = 'none';
            
            if (!isTouchDevice()) document.body.requestPointerLock(); 
        }
    }
}

// --- PEDESTRIANS ---
function initPedestrians() {
    const pedColors = [0xffffff, 0xaaaaaa, 0x3355aa, 0xaa3333, 0x33aa33];
    for(let i=0; i<50; i++) {
        const group = new THREE.Group();
        const col = pedColors[Math.floor(Math.random()*pedColors.length)];
        
        // Simple Humanoid (Similar to player)
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c }); 
        const clothesMat = new THREE.MeshStandardMaterial({ color: col }); 

        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), clothesMat); torso.position.y = 1.1; group.add(torso);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.3), skinMat); head.position.y = 1.7; group.add(head);
        const legL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.75, 0.2), clothesMat); legL.position.set(-0.15, 0.4, 0); group.add(legL);
        const legR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.75, 0.2), clothesMat); legR.position.set(0.15, 0.4, 0); group.add(legR);

        // Random Spawn on grid lines (Sidewalks approx)
        let x = (Math.random() - 0.5) * 800;
        let z = (Math.random() - 0.5) * 800;
        // Snap to grid-ish?
        // Just avoid buildings
        if(checkCollisionWithBuildings(x, z, 1)) x+=5;

        group.position.set(x, 5, z);
        scene.add(group);
        
        pedestrians.push({
            mesh: group,
            parts: { legL, legR },
            dir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(),
            isDead: false,
            radius: 0.6
        });
    }
}

function updatePedestrians(dt) {
    pedestrians.forEach(p => {
        if(p.isDead) return;

        // Move
        let nextPos = p.mesh.position.clone().add(p.dir.clone().multiplyScalar(3 * dt)); // Walk speed 3
        
        // Wall bounce
        if(checkCollisionWithBuildings(nextPos.x, nextPos.z, 0.5)) {
            p.dir.negate();
            p.dir.applyAxisAngle(new THREE.Vector3(0,1,0), Math.random()); // Random turn
        } else {
            p.mesh.position.copy(nextPos);
        }
        
        // Floor
        p.mesh.position.y = 0.9;
        
        // Rotate
        p.mesh.lookAt(p.mesh.position.clone().add(p.dir));

        // Anim
        p.parts.legL.rotation.x = Math.sin(clock.elapsedTime * 8) * 0.5;
        p.parts.legR.rotation.x = Math.sin(clock.elapsedTime * 8 + Math.PI) * 0.5;
    });
}

// --- PLAYER MODEL ---
function createPlayer() {
    const group = new THREE.Group();

    const skinMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c }); 
    const shirtMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); 
    const pantsMat = new THREE.MeshStandardMaterial({ color: 0x3355aa }); 

    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), shirtMat);
    torso.position.y = 1.1;
    group.add(torso);
    playerBodyParts.torso = torso;

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.3), skinMat);
    head.position.y = 1.7;
    group.add(head);
    playerBodyParts.head = head;

    const armGeo = new THREE.BoxGeometry(0.15, 0.6, 0.15);
    const armL = new THREE.Mesh(armGeo, skinMat);
    armL.position.set(-0.35, 1.1, 0);
    group.add(armL);
    playerBodyParts.armL = armL;

    const armR = new THREE.Mesh(armGeo, skinMat);
    armR.position.set(0.35, 1.1, 0);
    armR.rotation.x = -Math.PI / 2; 
    armR.position.set(0.35, 1.3, 0.2); 
    group.add(armR);
    playerBodyParts.armR = armR;

    const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.4), new THREE.MeshStandardMaterial({ color: 0x111111 }));
    gun.position.set(0, -0.3, 0.1); 
    armR.add(gun);
    playerBodyParts.gun = gun;

    const legGeo = new THREE.BoxGeometry(0.2, 0.75, 0.2);
    const legL = new THREE.Mesh(legGeo, pantsMat);
    legL.position.set(-0.15, 0.4, 0);
    group.add(legL);
    playerBodyParts.legL = legL;

    const legR = new THREE.Mesh(legGeo, pantsMat);
    legR.position.set(0.15, 0.4, 0);
    group.add(legR);
    playerBodyParts.legR = legR;

    group.position.set(0, 5, 0); 
    group.castShadow = true;
    scene.add(group);

    player = {
        mesh: group,
        velocity: new THREE.Vector3(),
        onGround: false,
        radius: 0.5
    };
}

function updatePlayer(dt) {
    if(gameState.isDriving) {
        player.mesh.visible = false;
        player.mesh.position.copy(activeVehicle.mesh.position);
        
        if(isTouchDevice()) {
            document.getElementById('btn-sprint').innerHTML = 'üí®'; 
            document.getElementById('btn-jump').innerHTML = 'üõë'; 
            document.getElementById('btn-shoot').style.display = 'none'; 
        }
        return;
    }
    
    player.mesh.visible = true;
    if(isTouchDevice()) {
        document.getElementById('btn-sprint').innerHTML = 'üèÉ'; 
        document.getElementById('btn-jump').innerHTML = 'üõë';
        document.getElementById('btn-shoot').style.display = 'flex';
    }

    const speed = input.shift ? CONFIG.sprintSpeed : CONFIG.playerSpeed;
    const moveDir = new THREE.Vector3();
    
    if (input.w) moveDir.z += 1; 
    if (input.s) moveDir.z -= 1;
    if (input.a) moveDir.x += 1;
    if (input.d) moveDir.x -= 1;

    moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngles.yaw);
    moveDir.normalize();

    if(moveDir.length() > 0) {
        playerBodyParts.legL.rotation.x = Math.sin(clock.elapsedTime * 10) * 0.5;
        playerBodyParts.legR.rotation.x = Math.sin(clock.elapsedTime * 10 + Math.PI) * 0.5;
    } else {
        playerBodyParts.legL.rotation.x = 0;
        playerBodyParts.legR.rotation.x = 0;
    }

    if (moveDir.length() > 0) {
        player.velocity.x = moveDir.x * speed;
        player.velocity.z = moveDir.z * speed;
        player.mesh.rotation.y = Math.atan2(player.velocity.x, player.velocity.z);
    } else {
        player.velocity.x *= 0.8;
        player.velocity.z *= 0.8;
        player.mesh.rotation.y = cameraAngles.yaw + Math.PI;
    }

    player.velocity.y -= CONFIG.gravity * dt;

    if (input.space && player.onGround) {
        player.velocity.y = 10;
        player.onGround = false;
    }

    let nextPos = player.mesh.position.clone().add(player.velocity.clone().multiplyScalar(dt));
    if(nextPos.y < 0.9) {
        nextPos.y = 0.9;
        player.velocity.y = 0;
        player.onGround = true;
    }
    resolveBuildingCollision(nextPos, player.radius, player.velocity);
    player.mesh.position.copy(nextPos);

    // Prompt Logic
    let minDst = 100;
    vehicles.forEach(v => {
        let dst = player.mesh.position.distanceTo(v.mesh.position);
        if(dst < minDst) minDst = dst;
    });

    let prompt = document.getElementById('interaction-prompt');
    
    if(isTouchDevice()) {
        document.getElementById('btn-car').style.opacity = minDst < 6 ? 1 : 0.3;
        prompt.style.display = 'none'; 
    } else {
        // Show prompt only if near car AND not driving
        if(minDst < 6 && !gameState.isDriving) prompt.style.display = 'block';
        else prompt.style.display = 'none';
    }
}

function initMinimap() {
    const canvas = document.getElementById('minimap-canvas');
    canvas.width = 200;
    canvas.height = 200;
    minimapCtx = canvas.getContext('2d');
}

function updateMinimap() {
    if (!minimapCtx) return;
    const ctx = minimapCtx;
    const cityColors = activeCityConfig.colors || {};
    const groundColor = colorToCss(cityColors.ground ?? 0x111111);
    const buildingColor = colorToCss(cityColors.neonBlue ?? 0x555555, 0.55);
    const routeColor = colorToCss(cityColors.neonPink ?? 0xffff00);
    const destinationColor = colorToCss(cityColors.neonBlue ?? 0xffff00);
    const playerColor = colorToCss(cityColors.neonPink ?? 0xffffff);

    ctx.fillStyle = groundColor;
    ctx.fillRect(0, 0, 200, 200);

    const cx = 100;
    const cy = 100;
    const scale = 2; 

    const pPos = gameState.isDriving ? activeVehicle.mesh.position : player.mesh.position;
    
    ctx.fillStyle = buildingColor;
    cityBuildings.forEach(b => {
        let rx = b.x - pPos.x;
        let rz = b.z - pPos.z;
        let angle = cameraAngles.yaw + Math.PI;
        let nx = rx * Math.cos(angle) - rz * Math.sin(angle);
        let nz = rx * Math.sin(angle) + rz * Math.cos(angle);
        let screenX = cx + nx * scale / 5;
        let screenY = cy + nz * scale / 5; 
        ctx.fillRect(screenX - (b.w * scale / 5 / 2), screenY - (b.d * scale / 5 / 2), b.w * scale / 5, b.d * scale / 5);
    });

    missions.forEach(m => {
        if (!m.completed && !m.active) {
            let rx = m.startPos.x - pPos.x;
            let rz = m.startPos.z - pPos.z;
            let angle = cameraAngles.yaw + Math.PI;
            let nx = rx * Math.cos(angle) - rz * Math.sin(angle);
            let nz = rx * Math.sin(angle) + rz * Math.cos(angle);
            ctx.fillStyle = colorToCss(m.color ?? cityColors.neonPink ?? 0xff00ff);
            ctx.beginPath(); ctx.arc(cx + nx * scale/5, cy + nz * scale/5, 4, 0, Math.PI*2); ctx.fill();
        }
    });

    if (gameState.activeMission !== null) {
        const m = missions[gameState.activeMission];
        let rx = m.endPos.x - pPos.x;
        let rz = m.endPos.z - pPos.z;
        let angle = cameraAngles.yaw + Math.PI;
        let nx = rx * Math.cos(angle) - rz * Math.sin(angle);
        let nz = rx * Math.sin(angle) + rz * Math.cos(angle);
        ctx.strokeStyle = routeColor; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + nx * scale/5, cy + nz * scale/5); ctx.stroke();
        ctx.fillStyle = destinationColor; ctx.beginPath(); ctx.arc(cx + nx * scale/5, cy + nz * scale/5, 5, 0, Math.PI*2); ctx.fill();
    }

    ctx.save();
    ctx.translate(cx, cy);
    ctx.fillStyle = playerColor;
    ctx.beginPath();
    ctx.moveTo(0, -6); ctx.lineTo(4, 4); ctx.lineTo(0, 2); ctx.lineTo(-4, 4);
    ctx.fill();
    ctx.restore();
}

function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.1);

    if (gameState.wasted) {
        renderer.render(scene, camera);
        return;
    }

    updateTouchInput(dt);

    for(let i=tracerLines.length-1; i>=0; i--) {
        tracerLines[i].life -= dt;
        tracerLines[i].mesh.material.opacity = tracerLines[i].life * 10;
        if(tracerLines[i].life <= 0) {
            scene.remove(tracerLines[i].mesh);
            tracerLines.splice(i, 1);
        }
    }

    updatePlayer(dt);
    updateVehicles(dt);
    updatePedestrians(dt);
    updateMissions();
    updateCamera(dt);
    updateMinimap();

    if (player.mesh.position.y < -10 || (activeVehicle && activeVehicle.mesh.position.y < -10)) {
        triggerWasted();
    }

    renderer.render(scene, camera);
}

function triggerWasted() {
    if(gameState.wasted) return;
    gameState.wasted = true;
    document.getElementById('wasted-screen').style.opacity = 1;
    document.getElementById('wasted-text').style.transform = 'scale(1.2)';
    if (!isTouchDevice()) document.exitPointerLock();
    setTimeout(() => { location.reload(); }, 4000);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

setupCitySelection();

</script>
</body>
</html>
